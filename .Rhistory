integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='beta')
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mix_beta')
# Defining the random Mixture Beta
sample_mixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else{
distr = mixture_beta
sample_distr = function(n) sample_mixture(n)}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mix_beta')
lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mix_beta')
rm(list=ls())
library(VGAM)
# Setting parameters
n <- 1000
m <- 10
h <- 1/m
eps <- .001
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat ){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- p_hat[interval == levels]
return(f)
}
# Defining step functions for q_hat
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- q_hat[interval == levels]
return(f)
}
# Defining Mixture of Beta
mixture_beta <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
# Defining the random Mixture Beta
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else{
distr = mixture_beta
sample_distr = function(n) rmixture(n)}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mix_beta')
lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mix_beta')
a <- simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mix_beta')
a <- lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mix_beta')
View(a)
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = mixture_beta
sample_distr = function(n) rmixture(n)}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mixture')
rm(list=ls())
library(VGAM)
# Setting parameters
n <- 1000
m <- 10
h <- 1/m
eps <- .001
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat ){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- p_hat[interval == levels]
return(f)
}
# Defining step functions for q_hat
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- q_hat[interval == levels]
return(f)
}
# Defining Mixture of Beta
mixture_beta <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
# Defining the random Mixture Beta
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = mixture_beta
sample_distr = function(n) rmixture(n)}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mixture')
a <- lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mix_beta')
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = mixture_beta
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'")}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='mixture')
a <- lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mix_beta')
a <- lapply(5:8, simulation_function, sim_size = 2, n=n, h = 1/m , eps = eps, func='mixture')
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='lol')
rm(list=ls())
library(VGAM)
# Setting parameters
n <- 1000
m <- 10
h <- 1/m
eps <- .001
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat ){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- p_hat[interval == levels]
return(f)
}
# Defining step functions for q_hat
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- q_hat[interval == levels]
return(f)
}
# Defining Mixture of Beta
mixture_beta <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
# Defining the random Mixture Beta
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = mixture_beta
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
simulation_function(m , sim_size = 10, n=n, h = 1/m , eps = eps, func='lol')
source("Simulation_Function.r")
source("Simulation_Function.r")
u <- rbeta( 10,10)
u <- rbeta(1, 10,10)
source("Simulation_Function.r")
source("Simulation_Function.r")
source("Simulation_Function.r")
source("Simulation_Function.r")
curve(mixture(x))
curve(mixture_beta(x))
curve(mixture_beta(x, pi=.2))
curve(mixture_beta(x, pi=.9))
hist(rmixture(1000))
hist(rmixture(1000), freq=F)
curve(mixture_beta(x), add = T)
library(VGAM)
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat ){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- p_hat[interval == levels]
return(f)
}
# Defining step functions for q_hat
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
levels   <- levels(interval)
f        <- q_hat[interval == levels]
return(f)
}
# Defining Mixture of Beta
dmixture <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
# Defining the random Mixture Beta
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
print(m)
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = dmixture
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
a <- lapply(5:50, simulation_function, sim_size = 100, n=100, h = 1/m , eps = eps, func='beta')
simulation_function <- function(m , sim_size = 100, n=100, eps = .1, func='beta'){
print(m)
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = dmixture
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
for(rep in 1:sim_size){
integral_p <- c()       # Pre-allocate the vector of the integral
integral_q <- c()       # Pre-allocate the vector of the integral
X <- sample_distr(n)   # Generating the random sample from the beta
h = 1/m
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the function to integrate
to_integrate_1 <- function(x) {return(( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat ))^2)}
to_integrate_2 <- function(x) {return(( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2)}
# Compute the integral
p <- integrate( Vectorize(to_integrate_1) , lower = 0 , upper = 1, subdivisions=2000)$value
q <- integrate( Vectorize(to_integrate_2) , lower = 0 , upper = 1, subdivisions=2000)$value
integral_p <- c(integral_p, p)
integral_q <- c(integral_q, q)
}
mise_p <- mean(integral_p)   #Save the results
mise_q <- mean(integral_q)   #Save the results
return(c(mise_p , mise_q))
}
a <- lapply(5:50, simulation_function, sim_size = 100, n=100, h = 1/m , eps = eps, func='beta')
a <- lapply(seq(5,8,1), simulation_function, sim_size = 100, n=100, h = 1/m , eps = eps, func='beta')
a <- lapply(seq(5,8,1), simulation_function, sim_size = 100, n=100 , eps = eps, func='beta')
a <- lapply(5:8, simulation_function, sim_size = 100, n=100 , func='beta')
knitr::opts_chunk$set(echo = TRUE)
par(mfrow = c(1,2))
C <- 2 #cost i order to enter the game
costs <- rep(C , M)
